Project To-Do (v1 Completion)
Rules

Do NOT over-engineer

One core game loop

Thin “modes” that toggle behavior

No new systems unless absolutely required

1. Core game state + screens

Implement GameState

mode (free | level)

screen (menu | game)

goal (null or object)

Menu screen → start game

Game screen → back to menu

Game screen owns all in-game buttons (auto-hide via screen toggle)

2. Implement goal system (core mechanic)

This is the heart of the project. Do this early.

Define goals as data

Centralize goal selection in one function

Store active goal on game start (Level Mode only)

Example:

GameState.goal = setRandomGoal(board);

3. Goal detection (arrival check)

On every player move:

Check if player is adjacent to goal

Do NOT trigger on overlap (adjacent only)

Return relative direction (left / right)

4. “You can see it on your left/right” logic

Calculate relative direction based on:

Player orientation

Goal position

Display helper text when condition is met

This text is the success signal in Level Mode

5. Level Mode vs Free Mode (behavior toggle)

No new UI systems.

Free Mode

No goals

No success state

Player moves freely (teacher / pair work)

Level Mode

Random goal on start

Success when helper text triggers

Show “Next” button on success only

Logic example:

if (GameState.mode === "level") {
checkGoal();
}

6. Next / Restart flow

“Next” button:

Clears current goal

Sets a new random goal

Back to Menu:

Clears board

Clears goal

Resets GameState

No partial resets.

7. Levels (intentional but minimal)

Do NOT build procedural generation yet.

Treat level as config only

Even one real level is fine

Example:

const LEVELS = {
1: { size: 5, boardFn: setBoard }
};

8. Layout cleanup (minimal CSS)

No art pass. Just clarity.

Center board

Group controls

Scale tiles responsively

Clear helper text placement

Enough to look intentional in a portfolio.

9. Stub future features (do not implement)

Character select (disabled button or fixed value)

Additional levels

More goal types

Only stubs. Zero logic.

10. Final polish (portfolio-ready)

Rename files clearly

gameState.js

goalSystem.js

Remove commented TODOs

Short README section:

Target audience (ESL learners)

Classroom usage

Learning objective (directions / spatial language)

Build order (recommended)

GameState + screens

Goal system

Left / right logic

Level Mode success + Next

CSS cleanup

Fake levels

If you want next, we should do either:

Step-by-step goal detection wiring

Or a strict “one move → one check → one render” loop cleanup

**Do NOT over-engineer.**

- One core game loop
- Thin “modes” that toggle behavior

## 3. Goal System (core ESL mechanic)

This is the **heart of the project**. Do this early.

### Define goals as data

``js
const GOALS = [
{ buildingIndex: 0, name: "Bank" },
{ buildingIndex: 1, name: "Post Office" },
];

### Set goal

export function setRandomGoal(board) {
const buildings = board.flat().filter(c => c.map === "building");
const target = buildings[Math.floor(Math.random() * buildings.length)];
return target;
}

Store it:
GameState.goal = setRandomGoal(board);

## 4. “You can see it on your left/right” logic

This is clean and impressive pedagogically.

### How to detect arrival

When player moves:

```js
function checkGoal(player, goal) {
  const dx = goal.x - player.x;
  const dy = goal.y - player.y;

  if (Math.abs(dx) + Math.abs(dy) === 1) {
    return getRelativeDirection(player.orientation, dx, dy);
  }
}
```

### Relative direction helper

```js
function getRelativeDirection(orientation, dx, dy) {
  if (orientation === "north") return dx === -1 ? "left" : "right";
  if (orientation === "south") return dx === 1 ? "left" : "right";
  if (orientation === "east") return dy === -1 ? "left" : "right";
  if (orientation === "west") return dy === 1 ? "left" : "right";
}
```

### Display

```js
helper.textContent = `You can see it on your ${direction}`;
```

This directly maps to Japanese textbooks. Huge value.

---

## 5. Teacher Mode vs Free Mode (toggle behavior)

No new systems. Just **conditional rules**.

### Free Mode

- Player walks freely
- No goal enforcement

### Teacher Mode

- Buttons disabled unless correct
- OR teacher announces goal verbally

Example:

```js
if (GameState.mode === "teacher" && !isCorrectMove) return;
```

That’s it. No extra UI needed yet.

---

## 6. Levels (fake complexity, real payoff)

Do NOT build procedural maps yet.

### Level = map config

```js
const LEVELS = {
  1: { size: 5, boardFn: setBoard },
  2: { size: 7, boardFn: setBoardLarge },
};
```

Switch by:

```js
GameState.level = 2;
loadLevel(GameState.level);
```

Even if only Level 1 exists now, this looks intentional.

---

## 7. Responsive + Cute Layout (minimal CSS changes)

You don’t need “game art polish”, just **intentional layout**.

### Key changes

- Center the board
- Scale tiles with `vw`
- Wrap buttons in a control panel

```css
#game-container {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

#btns {
  display: flex;
  justify-content: center;
  gap: 12px;
}
```

Optional:

- Round buttons
- Pastel background
- Larger helper text

That’s enough for a portfolio reviewer.

---

## 8. Character Select (stub only)

Do NOT implement fully yet.

Menu:

```html
<button disabled>Character Select (Coming Soon)</button>
```

Or:

```js
GameState.character = "boy";
```

Future-proof, zero effort.

---

## 9. Final polish checklist (portfolio-ready)

- Rename files clearly (`gameState.js`, `goalSystem.js`)
- Remove commented TODOs
- Add a short README:
  - Target audience
  - Classroom usage
  - ESL objective

---

## Where to start (order)

1. GameState + menu screen
2. Goal system + left/right logic
3. Teacher vs Free mode toggle
4. CSS cleanup
5. Levels (even fake ones)

If you want, next step we can:

- Implement **goal detection step-by-step**
- Or refactor **board + renderer** cleanly using Odin principles
- Or design **teacher classroom flow** (pair work, call-and-response)

Say which one.
